# Mysql 基础

## Mysql 启动

```
net start mysql80//启动数据库
net stop mysql80//停止数据库
//命令要在cmd下以管理员身份运行
```

## 数据库连接

```
mysql -u root -p
```

运行软件：MySQL 8.0 Command Line Client - Unicode

## 关系型数据库

概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库

## 数据模型

客户端连接数据库管理系统（DSMS，使用SQL语句通过DBMS创建多个数据库，也可以在指定的数据库中创建多个表

# Sql语句

## Sql的通用语法

1：sql语句可以单行或者多行书写，以分号结尾

2：sql语句可以使用空格/缩进来增强语句的可读性

3：Mysql数据库的sql语句不区分大小写，关键字建议使用大写

4：单行注释：--注释内容 或者 #注释内容

5：多行注释：/**/

## Sql分类

DDL语句：数据定义语句，用来定义数据库对象（数据库，表，字段）

DML语句：数据操作语言，用来对数据库表中的数据进行增删改查

DQL语句：数据查询语言，用来查询数据库中表的记录

DCL语句：数据控制语言，用来创建数据库用户，控制数据库的访问权限

## DDL

### 数据库操作

查询：

```
SHOW DATABASES;//查询所有数据库
SELECT DATABASE();//查询当前数据库
```

创建

```
CREATE DATABASE [IF NOT EXIST] 数据库名 [COLLATE 排序规则];
```

删除

```
DROP DATABSE [IF EXIST] 数据库名;
```

使用

```
USE 数据库名;
```

住：[]的部分可以省略，打命令的时候不要加上[] 

### 表操作

查询当前数据库所有表

```
SHOW TABLES;
```

查询表结构

```
DESC 表名;
```

查询指定表的建表语句

```
SHOW CREATE TABLE 表名;
```

### 表创建

```
CREATE TABLE 表名(
		字段1 字段1类型[COMMENT 字段1注释]
		字段2 字段2类型[COMMENT 字段2注释]
		...
		字段n 字段n类型[COMMENT 字段n注释]
)[comment 表注释];
```

### 数据类型

主要分为三类：数值类型，字符串类型，日期时间类型

### 表修改-删除

添加字段

```
ALTER TABLE 表名 ADD字段名 类型(长度) [COMMENT 注释] [约束];
```

修改数据类型

```
ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);
```

修改字段名和字段类型

```
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];
```

删除字段

```
ALTER TABLE 表名 DROP COLUMN 字段名;
```

修改表名

```
RENAME TABLE 表名 TO 新表名;
```

删除表

```
DROP TABLE [IF EXIST] 表名;
```

删除指定表，并重新创建该表

```
TRUNCATE TABLE 表名;
```

## DML

### 添加数据

给指定字段添加数据

```
INSERT INTO 表名 (字段1,字段2,...,字段n) VALUES (值1,值2,...值n);
```

给全部字段添加数据

```
INSERT INTO 表名 VALUES (值1,值2,..,值n);
```

批量添加数据

```
INSERT INTO 表名 (字段1,字段2,...,字段n) VALUES (值1,值2,..,值n),(值1,值2,..,值n),(值1,值2,..,值n);
```

```
INSERT INTO 表名 VALUES (值1,值2,...,值n),(值1,值2,...,值n);
```

注意：
1：查润数据时，指定的字段顺序需要与值的顺序一一对应

2：字符串和日期型数据应该包含在引号中

3：插入的数据太小，应该在字段的规定范围内

### 修改数据

```
UPDATE 表名 SET 字段名1=值1,字段名2=值2,..[WHERE 条件];
```

注意：修改字段的条件可以有，也可以没有，如果没有，则会修改整张表的该字段的所有数据

### 删除数据

```
DELETE FROM 表名 [WHERE 条件];
```

注意：

DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据

DELETE不可以删除某一个字段的值(可以使用update将该字段的值设为null)

## DQL

### 语法结构

```
SELECT
		字段列表
FROM
		表名列表
WHERE
		条件列表
GROUP BY
	`	分组字段列表
HEAVING
		分组后条件列表
OEDER BY
		排序字段列表
LIMIT
		分页参数
			
```

### 基本查询

查询多个字段

```
SELECT 字段1,字段2,...FROM 表名;
SELECT * FROM 表名;//查询所有的字段
```

设置别名

```
SELECT 字段1 [AS 别名1],字段2 [AS 别名2]...FROM 表名;//AS也可以省略
```

去除重复记录

```
SELECT DISTINCT 字段列表 FROM 表名;
```

### 条件查询

语法

```
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

条件

| 比较运算符    | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| >             | 大于                                                         |
| >=            | 大于等于                                                     |
| <             | 小于                                                         |
| <=            | 小于等于                                                     |
| =             | 等于                                                         |
| <> 或 !=      | 不等于                                                       |
| BETWEED...AND | 在某个范围内（含最小，最大值）                               |
| IN(...)       | 在IN之后的列表中的值，多选一                                 |
| IS NULL       | 是NULL                                                       |
| LIKE 占位符   | 模糊匹配（_匹配单个字符，%匹配任意个字符，一个\_代表一个字符，%代表一串字符） |

| 逻辑运算符 | 功能                         |
| ---------- | ---------------------------- |
| AND 或 &&  | 并且（多个条件同时成立）     |
| OR 或 \|\| | 或者（多个条件满足任意一个） |
| NOT 或 !   | 非，不是                     |

### 聚合函数

介绍

将一列数据作为一个整体，进行纵向计算

常见的聚合函数

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

```
SELECT 聚合函数(字段列表) FROM 表名
```

注意：所有的null值不参与聚合函数的运算

### 分组查询

语法

```
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件]
```

WHERE和HAVING的区别

执行时机不同，where是分组之前进行过滤，不满足where条件，不参与分组，而having是分组之后对结果进行过滤

判断条件不同，where不能对聚合函数进行判断，而having可以

注意：

执行顺序：where>聚合函数>having

分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义，查询其他字段，一般会显示每组的第一个信息

### 排序查询

语法

```
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;
```

排序方式

ASC：升序（默认值）

DESC：降序

### 分页查询

语法

```
SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;
```

注意：
起始索引从0开始，起始索引=（查询页码-1）*（每页显示记录数）

分页查询是查询数据库的方言，不同的数据库有不同的实现，Mysql中是LIMIT

如果查询的是第一页的数据，起始索引可以省略，直接简写为limit 10

### 执行顺序

FROM > WHERE > GROUP BY > HEAVING > SELECT > ORDERBY > LIMIT

## DCL

### 管理用户

查询用户

```
USE mysql;
SELECT * FROM USER;
```

创建用户

```
CREATE USER '用户名'@'主机名' IDENTITY BY '密码'
```

修改用户密码

```
ALTER USER '用户名'@'主机名' IDENTITY WITH mysql_native_password BY '新密码';
```

删除用户

```
DROP USER '用户名'@'主机名';
```

### 权限控制

| 权限               | 说明               |
| ------------------ | ------------------ |
| ALL,ALL PRIVILEGES | 所有权限           |
| SELECT             | 查询数据           |
| INSERT             | 插入数据           |
| UPDATE             | 修改数据           |
| DELETE             | 删除数据           |
| ALTER              | 修改表             |
| DROP               | 删除数据库/表/视图 |
| CREATE             | 创建数据库/表      |

查询权限

```
SHOW GRANTS FOR '用户名'@'主机名';
```

授予权限

```
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
```

撤销权限

```
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```

注意：

多个权限之间，使用逗号分割

授权时，数据库名和表名可以使用*进行通配，代表所有

# 函数

## 字符串函数

| 函数                     | 功能                                                        |
| ------------------------ | ----------------------------------------------------------- |
| CONCAT(s1,s2,...sn)      | 字符串拼接，将s1,s2,..sn拼接成一个字符串                    |
| LOWER(str)               | 将字符串str全部转成大写                                     |
| UPPER(str)               | 将字符串str全部转成大写                                     |
| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串的长度 |
| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符串的长度 |
| TRIM(str)                | 去掉字符串头部和尾部的空格                                  |
| SUBSTRING(str,start,len) | 返回从字符串str从strat位置起的len个长度的字符串             |

注意：这里的字符串的索引从1开始

```
SELECT 函数(参数);
```

## 数值函数

| 函数       | 功能                               |
| ---------- | ---------------------------------- |
| CEIL(x)    | 向上取整                           |
| FLOUR(x)   | 向下取整                           |
| MOD(x)     | 返回x/y的模                        |
| RAND()     | 返回0-1内的随机数                  |
| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |

## 日期函数

| 函数                              | 功能                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| CURDATE()                         | 返回当前日期                                                 |
| CURTIME()                         | 返回当前时间                                                 |
| NOW()                             | 返回当前日期和时间                                           |
| YEAR(date)                        | 获取指定date的年份                                           |
| MONTH(date)                       | 获取指定date的月份                                           |
| DAY(date)                         | 获取指定date的日期                                           |
| DATE_ADD(date,INTERVAL expr type) | 返回上一个日期/时间值加上一个时间间隔expr后的时间值，type是单位 |
| DATEDIFF(date1,date2)             | 返回起始时间date1和结束时间date2之间的天数                   |

## 流程函数

| 函数                                                       | 功能                                                   |
| ---------------------------------------------------------- | ------------------------------------------------------ |
| IF(value,t,f)                                              | 如果value为true则返回值t，否则返回值f                  |
| IFNULL(value1,value2)                                      | 如果value不为空，则返回value1,否则返回value2           |
| CASE WHEN [val1] THEN [res1] ... ELSE [default] END        | 如果val1为true.返回trs1...否则返回default默认值        |
| CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END | 如果expr的值等于val1,返回res1,...否则返回default默认值 |

# 约束

## 常见约束

概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据

目的：保证数据库中数据的正确，有效性和完整性

分类：

| 约束     | 描述                                                     | 关键字      |
| -------- | -------------------------------------------------------- | ----------- |
| 非空约束 | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束 | 保证该字段的所有数据都是唯一的，不重复的                 | UNIQUE      |
| 主键约束 | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束 | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |
| 检查约束 | 保证字段值满足某一个条件                                 | CHECK       |
| 外键约束 | 用来上两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

注意：约束是作用于表中字段上的，可以在创建表/修改表的时候 添加约束

## 外键约束

概念：外键是用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性

语法：

```
CREATE TABLE 表名(
	字段名 数据类型,
	...
	[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)
);
```

```
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名);
```

删除/更新行为

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与RESTRICT一致） |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与NO ACTION一致） |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录 |
| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许null） |
| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值（lnnodb不支持） |

举例

```
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERNCES 主表名 (主表字段) ON UPDATE CASECADE ON DELETE CASCADE;
```



# 多表查询

## 多表关系

### 一对多（多对一）

案例：部门与员工的关系

关系：一个部门对应多个员工，一个员工对应一个部门

实现：在多的一方建立外键，指向一的一方的主键

### 多对多

案例：学生与课程的关系

关系：一个学生可以选择多门课程，一门课程也可以供多个学生选择

实现：建立第三张中间表，中间至少包含两个外键，分别关联两方主键

### 一对一

案例：用户与用户详细的关系

关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中

实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 

## 多表查询概述

笛卡尔积：笛卡尔积是指在数学中，两个集合吧A，B集合的所有组合情况，（在多表查询中需要消除无效的笛卡尔积的情况）

### 多表查询分类

#### 连接查询

内连接：相当于查询A，B交集部分的数据

外连接：	

​		左外连接：查询左表所有数据，以及两张表交集部分的数据、

​		右外连接：查询右表所有数据，以及两张表交集部分的数据

自连接：当前表与自身的连接查询，自连接必须使用表别名

子查询

## 内连接

隐式内连接

```
SELECT 字段列表 FROM 表1,表2 WHERE 条件;
```

显式内连接

```
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;
```

注意：如果已经给表起了别名，则不能通过原表名进行操作

查找两张表的交集部分

内连接举例：查询员工的姓名及关联的部门名称（这里有部门名称的员工才会显示，没有的部分不显示）

## 外连接

### 左外连接

```
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;
```

### 右外连接

```
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
```

外连接举例：查询emp表的所有数据，和对应的部门信息，（这里就算没有员工信息，也会显示）

**哪边显示的数据全，就选对应边的外连接**

## 自连接

语法

```
SELECT 字符列表 FROM 表A IN 表A 别名 ON 条件
```

自连接查询，可以是内连接，也可以是外连接查询

## 联合查询

```
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字符列表 FROM 表B...
```

加ALL去重，不加不去重，联合查询要有相同的列

## 子查询（嵌套查询）

```
SELECT * FROM t1 WHERE column1 =(SELECT column FROM t2)
```

子查询的外部语句可以是INSERT/UPDATE/DELETE/SELECT中的任何一个

根据结果不同可以分为：

​	标量子查询（子查询结果为单个值）

​	列子查询（子查询结果为1列）

​	行子查询（子查询结果为1行）

​	表子查询（子查询结果为多行多列）

根据子查询的位置：WHERE之后，FROM之后，SELECT之后

### 标量子查询

举例：查询”销售部“员工的信息，两部分先查询销售部id，在拿着id查询对应的员工信息

常用操作符为条件查询常用的操作符



### 列子查询

返回的结果是一列的子查询

常用的操作符：	IN,NOT IN,ANY,SOME,ALL



| 操作符 | 描述                                   |
| ------ | -------------------------------------- |
| IN     | 在指定的范围内多选一                   |
| NOT IN | 不在指定的集合范围内                   |
| ANY    | 子查询返回的列表中，有任意一个满足即可 |
| SOME   | 与ANY等同，使用SOME的地方可以使用ANY   |
| ALL    | 子查询返回列表的所有值都必须满足       |



### 行子查询

返回的结果是一行，这种查询称为行子查询

常用操作符:= <> IN NOT IN

```
SELECT * FROM EMP WHERE (salary,managerid)=(SELECT salary,managerid from emp where name='张无忌')
```

### 表子查询

查询的结果是吧多行多列

常用操作符IN.

# 事务

**事务简介**:是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

## 事务操作

查看/设置事务提交方式

```
SELECT @@autocommit
SET @@autocommit=0//初始值1自动提交，改为0变手动控制
```

开启事务

```
START TRANSACTION;
BEGIN;
```

提交事务

```
COMMIT;
```

回滚事务

```
ROLLBACK;
```

## 事务四大特性

原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败

一致性：事务完成时，必须使所有数据保持一致状态

隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行

持久性：事务一旦提交或回来，它对数据库中数据的改变就是永久的

## 并发事务问题

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没有提交的数据                       |
| 不可重复读 | 一个事务先后读到同一条记录，但两次读取的数据不同，称之为不可重复读 |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现一个幻影 |

## 事务隔离级别

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | +    | +          | +    |
| Read committed   | /    | +          | +    |
| Repeatable Read  | /    | /          | +    |
| Serializable     | /    | /          | /    |

```
SELECT @@TRANSACTION_ISOLATION;//查看事务隔离级别

SET [SESSION|GLOBAL] TRANSCATION ISOLATION LEVEL {READ UNCOMMITTED|READ COMMITED|REPEATABLE READ|SERIALIZABLE}

```

注意：事务的隔离级别越高，数据越安全，但是性能越低

# 存储引擎

## Mysql体系结构

连接层，服务层，引擎层，存储层

## 简介

```
ENGINE=INNODB//设置数据库引擎，默认INNODB，加在见表语句的大括号后面
SHOW ENGINES//查看当前数据库支持的引擎
```

## 存储引擎特点

### INNODB

innodb是一种兼顾可靠性和高性能的通用存储引擎，在mysql5.5之后是默认的引擎

特点：DML操作遵循ACID模型，行级锁，提高并发访问性能，支持外键约束，保证数据的完整性和正确性

适用情况：对事物完整性要求较高，并发条件下强调事务一致性，除了插入和查询操作外，包含很多更新，删除操作

### MYISAM

MYISAM是mysql早期的默认引擎

特点：不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快

适用情况：对事物完整性和并发性要求不高，以插入和查询操作为主，不包含很多更新，删除操作

### Memory

Memory引擎的表数据存储在内存中，受硬件问题的影响

特点：内存存放，hash索引

适用性：临时表存储

# 索引

介绍：帮助mysql高效获取数据的数据结构，可以提高查询，排序效率，但是占用磁盘空间，且降低更新速度

## 索引结构

| 索引结构            | 概述                                                         | INNODB    | MYISAM | Memory |
| ------------------- | ------------------------------------------------------------ | --------- | ------ | ------ |
| B+Tree              | 最常见的索引类型，大部分引擎都支持                           | 支持      | 支持   | 支持   |
| Hash                | 底层数据结构用哈希表实现，只有精确匹配索引例的查询才有效，不支持范围查询 | 不支持    | 不支持 | 支持   |
| R-tree(空间索引)    | 空间索引是MYISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，使用较少 | 不支持    | 支持   | 不支持 |
| Full-text(全文索引) | 通过建立倒排索引，快速匹配文档的方式，类似于Lucene,Solr,ES   | 5.6后支持 | 支持   | 不支持 |

### B-tree（多路平衡查找树）

以一颗最大度数为5的b-tree为例，每个节点最多存4个key，5个指针，每个指针指向的是这四个数字所划分的五个区间范围内的数，当度数大于阶数时，中间的数向上裂变

### B+tree

区别于B-tree，叶子节点之间会有指针，从而产生一个单向链表，且所有的数据会出现在叶子节点，mysql中的叶子几点是一个双向循环链表

### Hash

原理同哈希表

## 索引分类

| 分类     | 含义                                                 | 特点                   | 关键字   |
| -------- | ---------------------------------------------------- | ---------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个             | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个             |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个             | FULLTEXT |

根据索引的存储形式分类

| 分类     | 含义                                                       | 特点               |
| -------- | ---------------------------------------------------------- | ------------------ |
| 聚集索引 | 将数据索引放到一起，索引结构的叶子节点保存行数据           | 必须有，且只有一个 |
| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存多个         |

规则：
如果存在主键，主键索引就是聚集索引

如果不存在主键，将使用第一个唯一索引为聚集索引

如果表没有主键，或没有合适的唯一索引，则INNODB会自动生成一个robid作为隐藏的聚集索引

解释：二级索引下面挂的其实就是一级索引

## 索引语法

创建索引

```
CREATE [UNIQUE|FULLTEXT] INDEX index-name ON table_name (index-col_name)
```

查看索引

```
SHOW INDEX FROM table_name;
```

删除索引

```
DROP INDEX index_name ON table_name;
```



## 索引使用

最做左前缀法则

如果索引了多列，要遵守该法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过则可能失效

# SQL性能分析

查看数据库INSERT UPDATE DELETE SELECT的访问次数

```
SHOW DLOBAL STATUS LIKE 'Com_______';
```

慢查询日志：记录所有运行时间超过指定参数的所有sql语句

查看mysql是否支持profile操作

```
SELECT @@have_profiling;
SET profiling = 1
```

# 视图

创建

```
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED|LOCAL|CHECK OPTION]]
```

查询

```
SHOW CREATE VIEW 视图名称  //查看创建的视图及其语句
SELECT * FROM 视图名称  //查看视图数据
```

修改

```
CREATE [ON REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED|LOCAL|CHECK OPTION]]
ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED|LOCAL|CHECK OPTION]]
```

删除

```
DROP VIEW [IF EXIST] 视图名称
```

补充

```//。
[WITH[CASCADED|LOCAL|CHECK OPTION]]//检查插入的数据是否满足视图的创建
```
